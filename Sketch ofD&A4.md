##串-《数据结构与算法》6.8
有限长度的字符序列，即限定数据元素为字符的线性表  
两个串相等当且仅当  

	两个串的长度相等
	每个对应位置的字符相同
###串匹配
	已知目标串T 和模式串P，模式匹配就是要在目标串T 中找到一个与模式串P 相等的子串
**Brute-Force 布鲁特福斯算法**  

    最坏情况下的时间复杂度为O(n×m)  
**KMP 算法**  
当模式P 不匹配时，尽量向右移动最大距离，避免重复  
*预处理函数Next*  

	void Next(char *P) 
	{
		int m = strlen(P); // 模式串P 的长度
		N[0] = 0; // 位置0 处的部分匹配串长度为0
		int i = 1; j = 0; // 初始化比较位置
		while(i < m) 
		{
			if(P[i] == P[j])  // 已经匹配了j+1 个字符
			{			
				N[i] = j+1; // 部分匹配串长度加1
				i++; j++;  // 比较位置各加1
			}
			else if( j > 0) j = N[j-1]; // 移动：用部分匹配串对齐
			else f N[i++] = 0;g //j 在串头时部分匹配串长度为0
		}
	}

KMP 算法的时间复杂度为O(m + n)  
**Boyer-Moore 算法**  
将模式串P 与主串T 的子序列进行反向比较  
若P 包含c，则移动P 使c 在P 中的最后一次出现P[l] 对准T[i]  
否则，移动P 使P[0] 对准T[i+1]  
最坏情况下，算法的时间复杂度为O(n × m + s)  

##树  
树是由n≥0 个结点组成的集合，有一个根（Root）结点，它只有直接后继，无直接前驱  
除根以外的其它结点划分为m > 0 个不相交的有限集合，每个集合又是一棵树，并称之为根的子树  
<img src="./img/4-1.jpg"  height=200> 
###二叉树
二叉树是k = 2 的k 叉树  
二叉树有五种不同形态  
<img src="./img/4-2.jpg"  height=50>  
具有n 个结点的完全二叉树的深度为log2 (n + 1)  
**二叉树的链式存储**   

	数据域：存放数据  
	指针域：存放指向左子树和右子树的指针

	typedef struct tnode 
	{
		ElemType data;
		struct tnode *lchild;
		struct tnode *rchild;
	} TreeNode;
**二叉树遍历**——访问根结点的时机选择  
先序遍历：V - L - R  
中序遍历：L - V - R  
后序遍历：L - R - V  
**以上三种用递归来实现**  
层序遍历 用队列来实现  
**二叉树的建立**  
由二叉树的先序序列和中序序列可唯一地确定一棵二叉树  
###Huffman 树与编码
树的路径长度：从树根到所有叶子结点的路径长度之和  
在所有路径相同的二叉树中带权路径长度最小的树称为Huffman树或最优二叉树  
**构造** 参考离散  
**Huffman 编码**  
平均编码长度最短
满足前缀编码的性质（任一字符编码都不是其它字符编码的前缀）  
**二叉搜索树**  
在二叉搜索树上可以高效地进行查找

##图
